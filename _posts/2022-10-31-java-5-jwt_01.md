---
layout: single
title:  "[JWT] - JWT(Json Web Token) #01"
excerpt: "JWT 기초설명"

categories:
  - web-5
tags:
  - [JWT]

toc: false
toc_sticky: false
 
date: 2022-10-31
last_modified_at: 2022-10-31
---
# JWT (Json Web Token)
- JWT(JSON Web Token)란 인증에 필요한 정보들을 암호화시킨 JSON 토큰을 의미.
- JWT 토큰(Access Token)을 HTTP 헤더에 실어 서버가 클라이언트를 식별하는 방식
- JSON 데이터를 Base64 URL-safe Encode 를 통해 인코딩하여 직렬화 
- 토큰 내부에는 위변조 방지를 위해 개인키를 통한 전자서명 포함.
- 사용자가 JWT 를 서버로 전송하면 서버는 서명을 검증하는 과정을 거치게 되며 검증이 완료되면 요청한 응답 반환.

## Session방식 인증

![Session](./../../images/sr_web/session_01.png)

1. 클라이언트가 id pw로 서버에 로그인 요청을 한다.
2. id pw로 인증 후 사용자를 식별할 특정 유니크한 세션 ID를 생성하여 서버의 세션 저장소에 저장.
3. 세션 ID를 특정한 형태(쿠키 or json)로 클라이언트에 다시 반환.
4. 이후 사용자 인증이 필요한 정보를 요청할 때마다 이 세션 ID를 쿠키에 담아 서버에 함께 전달.
5. 인증이 필요한 api일 때, 서버는 클라이언트가 보낸 세션 ID가 세션 저장소에 있는지 확인.
6. 있다면 인증 완료 후 api 처리, 없다면 401 에러를 반환.

### Session 방식의 문제점
- http의 가장 큰 특성중 하나인 stateless를 위배. stateless라면 서버는 클라이언트의 상태를 저장하지 않아야 하지만 세션 저장소라는 곳에서 클라이언트의 상태를 저장하게 되므로 stateful하게 됨.
- 서버분산환경 또는 서버를 scale out 에서 문제? 1번 서버에 로그인한 사용자가 다른 2번 서버로 요청을 보내게 된다면, 2번 서버에는 로그인 정보가 없기 때문에 다시 로그인해야 하는 상황이 발생, scale out에 걸림돌.

**사용자가 증가함에 따라 성능의 문제를 일으킬 수 있으며 확장성이 어렵다는 단점**

#### Session 방식의 문제점 해결
1. 세션 클러스터링
- 서버간 로그인 정보가 담긴 세션을 공유하는 방법
- 실제 서비스와 관련없는 인프라적인 작업으로 서버 리소스를 많이 쓰게 되는 단점.
- 전체적인 서버 규모가 크지 않다면 나쁘지 않은 방법이지만, MSA로 잘게 쪼개져 수십 수백개의 서버로 이루어진다면 단점이 극명하게 드러남.

2. 스티키 세션
- 여러 서버에 세션 정보를 복사할 필요 없도록 특정 세션을 처음 처리한 서버에게 이후 같은 세션의 요청을 같은서버가 처리하도록 하는 방식.
- A사용자가 맨처음에 A서버에게 요청했다면 이후 요청은 모두 A서버가 처리하는 방식.
- 문제점은 각 서버가 균일하게 요청을 처리할 수 없다는 점, 즉 로드밸런싱이 불균일하게 됨.

## 2. Token 방식 인증
### 2-1. Token 인증 등장
- **인증받은 사용자에게 토큰을 발급하고, 로그인이 필요한 작업일 경우 헤더에 토큰을 함께 보내 인증받은 사용자인지 확인**
- Session 사용시 stateful 특성을 stateless로 가능. 서버는 클라이언트의 상태를 갖고있지않음.
- 인증에 필요한 정보가 토큰에 들어있어서 별도의 저장소 불요.
  (단, 보안성을 높이기위해 Refresh Token을 사용하는경우 별도의 저장소에 저장하면서 사용하는 경우에는 해당하지 않음.)
- 다양한 언어에서 지원.
- HTTP 헤더에 넣어서 쉽게 전달 가능.

### 2-2. Token 인증 방식

![Token 01](./../../images/sr_web/token_01.png)

- 1. 사용자가 아이디와 비밀번호로 로그인.
- 2. 서버 측에서 사용자(클라이언트)에게 유일한 토큰을 발급.
- 3. 클라이언트는 서버 측에서 전달받은 토큰을 쿠키나 스토리지에 저장해 두고, 서버에 요청을 할 때마다 해당 토큰을 서HTTP 요청 헤더에 포함시켜 전달.
- 4. 서버는 전달받은 토큰을 검증하고 요청에 응답. 토큰에는 요청한 사람의 정보가 담겨있기에 서버는 DB를 조회하지 않고 누가 요청하는지 파악가능.

### 2-3. JWT 구조
- 각 부분을 구분하기 위한 . 구분자가 들어감.

![JWT 01](./../../images/sr_web/jwt_01.png)

#### 1) 헤더(Header)
- 헤더는 두 가지 정보를 가진다.
  - typ - 토큰의 타입(JWT)
  - alg - 해싱 알고리즘 (Signature를 해싱하기 위한 알고리즘 지정)

#### 2) 내용(Payload)
- 클레임(claim, 토근에 담아 전달하는 정보) property를 key-value의 형태로 저장
- json이 인코딩된 상태, 보안에 민감한 정보는 담지않음
- 표준 스펙상 key의 이름은 3글자.

>
> Registed claims : 미리 정의된 클레임.
>   - iss(issuer; 발행자), 
>   - exp(expireation time; 만료 시간), 
>   - sub(subject; 제목), 
>   - iat(issued At; 발행 시간), 
>   - jti(JWI ID)
> 
> Public claims : 사용자가 정의할 수 있는 클레임 공개용 정보 전달을 위해 사용.
> Private claims : 해당하는 당사자들 간에 정보를 공유하기 위해 만들어진 사용자 지정 클레임. 
>   외부에 공개되도 상관없지만 해당 유저를 특정할 수 있는 정보들을 설정
>

``` json
 페이로드 ex)
    {
        "iss": "jh.com", // 등록된 클레임
        "exp": "1485270000000", // 등록된 클레임
        "<https://xxx.com/jwt_claims/is_admin>": true, // 공개 클레임
        "userId": "11028373727102", // 비공개 클레임
        "username": "jh" // 비공개 클레임
    }
```

#### 3) 서명(Signature)
- 토큰을 인코딩하거나 유효성 검증을 할 때 사용하는 고유한 암호화 코드이다.
- 서명 생성 과정
  - 헤더와 페이로드값을 각각 BASE64로 인코딩
  - 1번에서 인코딩한 값을 비밀 키를 이용해 헤더에서 정의한 알고리즘으로 해싱
  - 2번에서 해싱한 값을 다시 BASE64로 인코딩

![JWT 02](./../../images/sr_web/jwt_02.png)


### 2-4. Refresh Token
- Access Token은 언제든지 탈취될 수 있다고 가정
- Access Token은 유효기간을 짧게 설정하고 Refresh Token의 유효기간은 길게 설정

#### 동작 방식

![Refresh_Token 01](./../../images/sr_web/refresh_token.png)

- 저장소 분리를 위하여 Access Token을 로컬 스토리지 또는 세션 스토리지에 저장.
- Refresh Token은 쿠키에 저장하고 보안 옵션들(HTTP Only, Secure Cookies)을 활성화.
- Refresh Token은 서버에도 저장되있어야 함.
