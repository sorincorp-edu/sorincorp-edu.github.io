---
layout: single
title:  "[MSA] - MSA 설계 접근법과 패턴"
excerpt: "MSA 아키텍처 설계 및 패턴, 유의사항 등"

categories:
  - MSA
tags:
  - [MSA]

toc: true
toc_sticky: true
 
date: 2022-02-22
last_modified_at: 2022-02-22
---
# MSA 설계 - MSA 아키텍처 설계 및 패턴, 유의사항 등
* 퍼온금 [출처](https://www.msaschool.io/operation/introduction/)

## 접근법과 분석패턴
### Approach #1: 마이크로서비스 아키텍처
초기의 마이크로서비스는 서비스의 자율성과 독립성, 서비스에 최적화된 저장소(Polyglot Persistence) 선택이 가능한 아키텍처로 고안되었습니다. 그러나, 서비스간 호출 시, 동기식 API 방식 (Requeste & Response)을 주로 사용함으로 인해 타임 커플링(Time Coupling)이라는 약점이 존재했습니다.

타임 커플링된 서비스들은 서비스 블로킹(Blocking) 우려와 한 서비스에서 발생한 장애가 타 서비스로 전파될 수 있는 약점을 가지고 있습니다. 이는 웹 스케일 기반 시스템에서는 치명적 단점으로, 이를 회로 차단(Circuit Breaking) 등의 방법으로 극복하려 하였습니다.

![마이크로서비스 아키텍처](./../../images/msasc/image1.df59cee.cfeedd12cb9002774ec84b609cd55647.png)

### Approach #2: 이벤트 드리븐(Event Driven) 아키텍처
이를 보완한 것이 최근 각광받고 있는 이벤트 기반(EDA)의 3세대 마이크로서비스입니다. 도메인에서 발생하는 이벤트를 분산된 큐를 통해 브로드캐스팅(BroadCasting)하고 Pub/Sub을 통해 상호 커뮤니케이션하는 아키텍처를 가집니다.

![이벤트 드리븐](./../../images/msasc/image2.1fc590d.c0f91660b5afea026d0b4a82264dfd18.png)

예를 들어, 주문이 발생하였을 때, 직접 배송팀에다 ‘’배송을 준비하세요.’라고 지시하는 것은 주문팀의 입장에서는 그다지 중요한 것이 아닙니다. 주문팀은 배송팀이 배송을 하던 말던 관심이 없다는 것입니다.

REST방식(직접 호출)으로 서로 통신할 경우, 요청자는 다음 액션을 수행하기 위해 응답이 도착할 때까지 기다려야 하는 블로킹(Blocking) 즉, 타임 커플링이 일어납니다.

만약, 주문팀이 발생한 사실에 대해 비동기 기반 큐(single Source Of Truth)에 “주문이 발생하였습니다.” 라고 신고만 하고, 이어지는 액션을 배송팀이 알아서 수행해도 됩니다.
이처럼 발생한 사실을 ‘신고’하고, 신고된 사실을 ‘구독’하는 패턴의 아키텍처가 이벤트 드리븐(Event Driven) (또는, 화이트보드 패턴) 아키텍처입니다.

그렇게 되면 초창기 MSA에서는 배송팀의 비즈니스 프로세스가 주문팀이 호출해 실행되던 방식이, 이벤트 드리븐 기반 MSA에선 배송팀이 직접 이벤트에 반응하여 실행하는 방식으로 실행 주체가 바뀌게 됩니다.

신설된 마케팅팀 또한, 주문팀의 주문 발생으로 수행해야 할 비즈니스 프로세스가 있다면, 단순하게 주문팀의 “주문이 발송하였습니다.” 라는 이벤트에 대해, 마케팅팀도 반응하여 수행하면 된다는 것입입니다.

이벤트 드리븐 아키텍처를 적용함으로써 얻어지는 장점 중의 하나는 폴리글랏 퍼시스턴스입니다. 각 마이크로서비스 팀들은 이제 나만의 데이터베이스를 가질 수 있습니다. 자기 만의 스토리지를 자기만의 아키텍처를 적용하여 구성할 수 있다는 것입니다.

주문팀은 사용자의 주문 정보만 관리하고, 상품팀은 전혀 다른 관점으로 상품의 재고 정보만을 관리합니다. 배송팀 또한, 주문 ID에 대해 배송 상태만 가집니다.

사업 초기, 모노리식 구조에선 간결한 스키마 였으나 서포팅 업무가 늘어남에 따라 주문팀 테이블의 컬럼이 많아지고, 여러 팀의 참조 Constraints로 인해, 점진적으로 분리가 불가능한 캐노니컬 모델 구조로 변모하게 됩니다.

![캐노니컬 모델 구조](./../../images/msasc/image3.8fd9c5a.96793f1be58796aeeb486e8658b4fa06.png)

이는 곧 대대적인 합의와 대대적인 리팩토링을 통해서만 수정이 가능한 비용 집약적 결과를 양산하게 됩니다.

그러나, 이벤트드리븐 아키텍처에서는 이벤트의 원천을 통해 각 팀이 필요에 의해 디자인하는, 디자인 책임이 분산된 환경을 추구함으로 모노리식에서의 데이터 참조 이슈가 없어집니다.

### Approach #3: BizDevOps 프로세스
비즈데브옵스는 비즈니스 유저를 뜻하는 ‘비즈’와 ‘데브옵스’가 결합된 의미로, 고객의 니즈를 인풋으로, 이를 개발하고 운영하는 것에 있어 단절을 최소화하는 것을 목적으로 합니다.

조직적으로는 Vertically aligned 되어 있어야 하고, 도구적으로는 이벤트스토밍을 적용해 그 결과 모델을 코드화하여, 자동화된 DevOps환경에서 운영하는 선 순환적 사이클이 비즈데브옵스 프로세스입니다.

이를 수행하는 방식(A way of working)이 흔히 알고 있는 스크럼으로, 스크럼과 위에 언급된 3가지 프랙티스가 버물러질 때, 비로소 ‘Agile’이 실현되는 것입니다.

![BizDevOps 프로세스](./../../images/msasc/image4.bc84cb6.2e4347def6c6d40a18f22686ee1f6853.png)

## 도메인 주도 설계
소프트웨어의 개발이 어려운 이유는 업무의 복잡성에서 시작됩니다. 개발자가 소프트웨어를 구현하는 복잡성보다 소프트웨어로 구현하고자 하는 기능(업무)에 대한 복잡성이 더 큽니다.

그래서, 업무를 가장 잘 이해하는 해당분야 전문가와 개발자 사이의 소통을 중심으로 특정 도메인을 개념적으로 표현한 모델을 통해, 여러 관계자들이 동일한 모습으로 도메인을 이해하고, 도메인 지식을 공유하는 것이 중요합니다.

고객의 요구사항이 모델로 유연하게 설계되고, 이 모델로부터 구현이 자연스럽게 연결되어야 한다는 사상이 Domain Driven Design 입니다.

이때, 가장 중요한 점은 여러 하위 도메인을 하나의 다이어그램에 모델링하면 안되고, 각 하위 도메인마다 별도로 모델을 만들어야 합니다. 모델의 각 구성요소는 특정 도메인으로 한정할 때, 비로소 의미가 명확해지기 때문입니다.

### 도메인 모델
> 도메인 모델이란 특정 도메인을 개념적으로 표현한 것입니다. 예를 들어, 쇼핑몰의 주문 도메인은 쇼핑몰에서 주문하기 위해 상품 수량을 선택하고, 배송지 정보를 입력합니다. 선택한 상품 가격과 수량으로 지불 금액을 계산하고 결제 수단을 선택합니다.
>
> 주문한 뒤에도 배송 전이면 배송지 주소를 변경하거나 주문을 취소할 수 있습니다. 이 주문 도메인을 객체 모델로 구성하면 아래와 같습니다.

![도메인 모델](./../../images/msasc/image1.974fa74.f06e0d17233d6afcde389357594c9d22.png)

위 그림은 객체를 이용한 도메인 모델입니다.
도메인을 이해하려면 도메인이 제공하는 기능과 도메인의 주요 데이터 구성을 파악해야 하는데, 이런 면에서 객체 모델은 도메인을 모델링하기에 적합합니다.

위 객체 모델은 도메인의 모든 내용을 담고 있지는 않지만 이 모델을 보면 주문(Order)은 주문번호와 지불할 총 금액이 있고, 배송정보(Shipping Information)를 변경할 수 있음을 알 수 있습니다.
또한, 주문을 취소할 수 있다는 것도 알 수 있습니다.

즉, 도메인 모델을 사용하면 여러 관계자들이 동일한 모습으로 도메인을 이해하고 도메인 지식을 공유하는데 도움이 됩니다.

이러한 도메인은 다수의 하위 도메인으로 구성됩니다. 각 하위 도메인이 다루는 영역은 서로 다르기 때문에 같은 용어라도 하위 도메인마다 의미가 달라질 수 있습니다.

예를 들어, 상품 도메인 내에서 상품이 상품가격, 상품이미지 URL, 재고 수량 등의 상세 내용을 담고 있는 ‘정보’를 의미한다면 배송 도메인의 상품은 고객에게 실제 배송되는 ‘물리적인 상품’을 의미합니다.

도메인에 따라 용어의 의미가 결정되므로, 여러 하위 도메인을 하나의 다이어그램에 모델링하면 안됩니다. 상품과 배송 도메인 모델을 구분하지 않고 하나의 다이어그램에 함께 표시한다면, 다이어그램에 표시한 ‘상품’은 상품 도메인의 상품인지, 배송 도메인의 상품인지 제대로 이해하기가 힘듭니다.

모델의 각 구성요소는 특정 도메인을 한정(Bounded)할 때, 비로소 의미(Context)가 완전해지기 때문에, ‘상품’의 의미가 통용되는 경계를 구분(Boundary Definition)하고 그 경계 내에서 별도로 도메인 모델을 만들어야 합니다.

#### Bounded Context (한정된 문맥)
[도메인 모델과 경계]
상품 도메인에서의 상품, 배송 도메인에서의 상품, 주문 도메인에서의 상품은 이름만 같지만 실제로 의미하는 것이 다릅니다.
상품 도메인에서의 상품은 상품 이미지, 상품명, 상품 가격, 상품 상세 설명과 같은 상품 정보가 위주라면 주문 도메인에서의 상품은 주문 대상이 되는 객체이며, 배송 도메인에서의 상품은 고객에게 배송되는 물리적 상품을 나타냅니다. 또한, 상품 도메인에서 물리적으로 하나인 상품은 주문 및 배송 도메인에서는 여러 개 존재할 수 있습니다.

논리적으로 같은 존재처럼 보이지만, 하위 도메인에 따라 서로 다른 용어를 사용하는 경우도 있습니다. 시스템을 사용하는 사람을 회원도메인에서는 회원이라고 부르지만, 주문 도메인에서는 주문자라고 부르고, 배송 도메인에서는 보내는 사람이라 부르기도 합니다.

SW 도메인과 건축 도메인에서도 동일한 용어지만 두 도메인 내에서의 의미가 서로 다른 예를 찾을 수 있는데, SW 도메인에서의 ‘프로젝트’가 현업이 요구하는 시스템을 개발하기 위한 전체 과정을 일컫는다면, 건축 도메인에서의 ‘프로젝트’는 사람이 주거하기 위한, 또는 생업에 필요한 건축물을 짓는 과정입니다.

‘아키텍처’란 용어도 SW 도메인에서는 서버, 네트워크, 소프트웨어 구성도나 ERD, UML과 같은 다이어그램 등을 지칭하나, 건축 도메인에서의 ‘아키텍처’는 건축물 구축에 필요한 평면도와 같은 설계 도면을 의미합니다.

![아키텍처](./../../images/msasc/image2.978a99b.eddd1fbbce7583fb6ffce63b17fba68f.png)

이렇듯, 도메인마다 같은 용어라도 의미가 다르고, 같은 대상이라도 지칭하는 용어가 다를 수 있기 때문에 한 개의 모델로 모든 하위 도메인을 정확하게 표현할 수는 없으며, 올바른 도메인 모델을 개발하려면 하위 도메인마다
모델을 만들어야 합니다.

이 때, 여러 하위 도메인이 섞이기 시작하면 모델의 의미가 약해지기 때문에, 각 모델은 명시적으로 구분되는 경계를 가져서 서로 섞이지 않도록 해야 하는 것이 중요합니다.

#### [Bounded Context]
모델은 특정한 경계 문맥(Context) 내에서 정확히 구분 가능한 완전한 의미를 가지는데, 이렇게 구분되는 경계를 DDD에서 바운디드 컨텍스트(Bounded Context) 라고 부릅니다.

즉, 바운디드 컨텍스트는 동일한 컨텍스트의 범위를 표현하는 경계로 해당 경계 내에서 모델은 특정한 의미를 지니고 특정한 일을 수행합니다.

바운디드 컨텍스트는 모델의 경계를 결정하며, 한 바운디드 컨텍스트는 논리적으로 하나, 또는 하나 이상의 모델을 가짐니다.

바운디드 컨텍스트는 도메인 구성원들이 사용하는 언어를 기준으로 구분 가능합니다. 쇼핑몰의 ‘상품’, 및 ‘회원’ 이라는 용어에 대해, 주문/결제 도메인과 배송 도메인 각각 서로 의미하는 바가 다르기 때문에, 두 도메인은 서로 다른 컨텍스트로 분리됩니다.

![아키텍처](./../../images/msasc/image3.bda6eff.2c72f34e03210bdc139290f4110017f9.png)

바운디드 컨텍스트는 도메인 모델을 구분하는 경계가 되기 때문에 바운디드 컨텍스트는 구현하는 서브 도메인에 알맞은 모델을 포함합니다.
같은 상품이라 하더라도 상품 바운디드 컨텍스트와 주문 바운디드 컨텍스트의 ‘상품’은 각 컨텍스트에 맞는 모델을 가집니다.

#### [Ubiquitous Language (도메인 언어)]
도메인 모델을 구분 짓는 경계인 바운디드 컨텍스트내에는 다양한 이해 관계자들이 존재합니다.
도메인 업무에 능통한 도메인 전문가, 개발이 가능한 뼈대를 세우는 아키텍트, 실제 서브 도메인 서비스를 구축하는 개발자가 포함될 수 있으며, 이들은 담당하는 각 서브 도메인의 모든 권한을 가집니다.

이러한 각 도메인별 소속 구성원들 간에는 원활한 의사 소통에 필요한 보편적 언어가 사용되는데 이를 도메인 언어, 또는 유비쿼터스 언어(Ubiquitous Language)라고 합니다.

![아키텍처](./../../images/msasc/image4.9fa36e9.258e3a832419176042872cf3e8239c62.png)

다시 말해, 한정된 맥락인 Bounded Context 내에서 협업 구성원들간 보편적으로 통용되는 도메인 언어가 유비쿼터스 언어입니다.

이러한 도메인 언어가 보편적이지 않다면, 개발자가 사용하는 용어를 도메인 전문가가 이해하지 못해, 도메인 전문가가 이해하는데 추가 비용이 들어갑니다.

구성원들이 각자의 언어를 사용하는 경우, 의사소통이 힘들어 상대방이 내뱉은 단어를 내가 사용하는 단어로 번역해서 이해해야 하고, 서로 협의된 내용에 대해서도 각자 해석이 달라지지 않도록 수식어를 달아야 합니다.

의사소통은 물론, 이벤트스토밍, 도메인 모델링, 프로그램 개발에 이르기까지 일관된 용어로 소통, 문서작성 뿐만 아니라 코드개발까지 일관된 언어가 사용되어야 바운디드 컨텍스트의 경계가 견실하게 유지될 수 있는 것입니다.

## 이벤트스토밍
이벤트스토밍은 Event와 BrainStorming의 합성어로 Domain Expert와 개발 전문가가 함께 모여 워크샵 형태로 진행되는 방법론입니다. DDD 방법론 중, 복잡한 UML다이어그램이나 도구 없이 수행할 수 있어 MSA를 구현하는데 가장 최적의 방법론입니다.

이벤트스토밍은 시스템에서 발생하는 이벤트를 중심(Event-First)으로 분석하는 기법으로 특히, Non-Blocking, Event-driven한 MSA 기반 시스템을 분석에서 개발까지 필요한 도메인에 대한 빠른 이해를 도모하는데 유리합니다.

기존의 유즈케이스나 클래스 다이어그래밍 방식은 고객 인터뷰를 통해 요구사항을 정제하고, 상세 설계를 통한 엔티티 구조를 인지하는 방식이었으나, 이벤트스토밍은 별다른 사전 훈련된 지식과 도구없이 진행할 수 있습니다.

![아키텍처](./../../images/msasc/image1.d72f1f4.03e2cc6e54aac02dffaff10ef26ee876.png)

진행 과정은 참여자 워크숍 방식의 방법론으로 결과는 스티키 노트를 벽에 붙힌 것으로 결과가 남으며, 오렌지 스티키 노트들의 연결로 비즈니스 프로세스가 도출되고 이들을 이후 BPMN과 UML등으로도 정제하여 전환할 수 있습니다.

### 개념
이벤트스토밍은 도메인에 관련된 모든 이해 관련자가 모여, 화이트보드 벽면에 주요 이벤트(Event)를 중심으로 업무들 간의 상호 연관성을 찾기 위해, 유일한 도구인 스티키 노트(Sticky Notes)로 진행하는 MSA DDD를 위한 워크숍 기반 최상의 실천 방법론입니다.

### 수행 방법
이벤트스토밍에 필요한 화이트 보드 벽면과 수행에 필요한 오렌지, 라일락, 스카이블루, 노랑, 초록, 퍼플, 분홍색의 스티커를 준비합니다.

![수행 방법](./../../images/msasc/image2.25ecf91.c432d468e1642bb18bcf3023815549b8.jpeg)

Domain expert 와 기획자, 개발 전문가와 함께 사용자 시나리오, 또는 업무 요건을 리뷰합니다.

가장 먼저, 발생 가능한 Event를 무작위로 도출하고, Policy, Command, Aggregate 순서로 이벤트를 중심으로 스티커별 해당 내용을 정의하고 발생시간 순서로 벽면에 부착합니다.

Bounded Context 를 설정하고 서브 도메인 간의 컨텍스트 매핑을 통해 BC간의 정보 참조의 릴레이션을 정의합니다.

#### 스티커 유형
이벤트스토밍에 필요한 스티커 색상별 내포하는 의미는 아래와 같습니다.

![수행 방법](./../../images/msasc/image3.46136f7.7bbe536d5f61bfa80cecd3c7db266e8b.png)

#### Step 1. [Event 정의]
가장 먼저 우리 서비스에서 발생하는 비즈니스 이벤트를 도출합니다. 용어의 네임스페이스를 구지 나누려 하지 말고 가급적 현업이 사용하는 용어를 그대로 사용(Ubiquitous Language)하여 오렌지색 스티커에 이벤트를 기술하고 이를 벽면에 붙입니다.

비즈니스 이벤트는 과거형으로 작성하는데 도메인 내부에 상태가 변화되고 난 결과가 이벤트 입니다.

![수행 방법](./../../images/msasc/image4.2bbca33.6bba5d9c593f7074d1552bd205019e68.png)

#### Step 2. [Policy 정의]
이벤트스토밍의 두번째 수행 대상은 폴리시(Policy) 도출입니다.

폴리시(Policy)는 이벤트가 발생한 후 연이어 발생하는 반응형 액션으로, 한 서비스 이벤트에 대해 수행되어야 할 타 서비스의 액션들로, 먼저 정의된 이벤트 아래에 덧대어 붙입니다.
하나의 이벤트에 반응하여 수행되어야 할 폴리시는 여러 팀에서 도출된 멀티 액션이 존재할 수 있습니다.

![수행 방법](./../../images/msasc/image5.fa8269c.4d56b91e467335dc1590eef1101924a0.png)

#### Step 3. [Command 도출]
세번째로 Event를 발생시키는 행위인 커맨드를 도출하는데, 도메인 내의 어떠한 상태 변화를 일으키는 서비스를 말합니다.
웹 페이지 내에서 버튼을 클릭하는 User Decision이 여기에 해당됩니다.
도출된 커맨드는 이벤트 스티커 앞쪽에 붙여, 스티커를 통한 나레이션(Narration)이 되도록 정렬합니다.

![수행 방법](./../../images/msasc/image6.e6340cf.e6eaaf7555e3b22086a8a7e08a08358c.png)

#### Step 4. [Actor 정의]
Actor는 커맨드를 발생시키는 주체(사람, 시스템, 등)를 말합니다. 액터는 담당자 또는 시스템이 될 수 있으며, 직관적으로 파악될 수 있는 액터의 경우, 표시하지 않아도 무방합니다. 도출된 액터는 유저 스토리에 가까운 나레이션이 가능하도록 해당 커맨드 스티커 왼쪽에 배치합니다.

![수행 방법](./../../images/msasc/image7.30df413.15ce0f19d3b57fa8165bbeb4a6508583.png)

#### Step 5. [Aggregate 정의]
다섯번째로, 어그리게잇을 도출합니다. 어그리게잇은 ‘결합물’을 의미하는데 어떠한 도메인 객체를 중심으로 하나의 ACID한 트랜잭션에 묶여 변화되어야 할 객체의 묶음을 도출하고, 그것들을 커맨드, 이벤트와 함께 묶습니다.

![수행 방법](./../../images/msasc/image8.c9c4c4d.0fee0a3d2d856605ac1c436215ed1070.png)

Step 6. [Bounded Context 도출]
Bounded Context는 동일한 문맥으로 효율적으로 업무 용어(도메인 클래스)를 사용할 수 있는 객체 범위를 뜻합니다. 하나의 BC는 하나 이상의 어그리게잇을 원소로 구성될 수 있습니다. 이 BC를 마이크로서비스 구성 단위로 정하게 되면 이를 담당하는 팀내의 커뮤니케이션이 효율화 됩니다.

![수행 방법](./../../images/msasc/image9.3b24fc3.04c28fb46523584bf7a76ec354b722ec.png)

#### Step 7. [Context 매핑]
바운디드 컨텍스트까지 도출된 이후에 BC간 정보 참조 릴레이션 설정 (혹은, 이벤트가 발생한 이후 동반된 행위의 호출 관계를 선으로 표시)하는 작업을 ‘컨텍스트 매핑’이라고 합니다. 컨텍스트간 매핑 정보만 보더라도 전체 도메인 서비스의 참조 토폴로지(Topology)를 한 눈에 파악 가능합니다.

![수행 방법](./../../images/msasc/image10.64e2d1d.b8c0087dcbfb79b84faa1dc2309547cd.png)

위 예시에서 ‘주문이력에 추가’라는 폴리시(비즈니스 업무) 시작 주체에 따라 크게 2가지 토폴로지를 고려할 수 있는데, 이벤트를 발행하는 주체인 주문관리에서 해당 폴리시를 시작하는 ‘오케스트레이션’ 방식과 이벤트를 수신하는 주체인 마케팅관리에서 폴리시를 시작하는 ‘코레오그래피’ 방식으로 구분합니다.

#### Orchestration(오케스트레이션)
오케스트레이션은 이벤트를 발행하는 주체인 주문관리에서 모든 폴리시를 호출하는 방식입니다.

![수행 방법](./../../images/msasc/image11.7426fad.691cf6dddb919ed7a5a6c182bf3591b8.png)

이는 주문관리 서비스에서 발생한 이벤트인 ‘주문 생성됨’, ‘주문정보 변경됨’, ‘주문상태 변경됨’에 붙여진 모든 폴리시의 Owner 서비스마다 커맨드를 노출하고, 이벤트를 생성하는 주문 서비스에서 이 커맨드를 동기 방식(Request & Response)으로 호출하는 방식으로 구현됩니다.

그러나, 이러한 방식은 서비스간 커플링이 높으며, 폴리시를 호출한 서비스(여기서는 주문관리)는 폴리시가 수행 완료될 때까지 대기상태에 빠지게 되므로, 시스템 블로킹(Blocking)이 생길 우려가 높습니다.

또한, 호출당하는 폴리시를 가진 시스템이 얘기치않은 장애(System Fault)에 빠진 경우, 이를 호출하는 서비스에까지 장애가 전파되는 악순환의 우려가 있습니다.

#### Choreography(코레오그래피)
코레오그래피는 폴리시를 구현하는 주체인 배송, 또는 상품관리에서 자율적으로 폴리시를 실행하는 방식입니다.

주문관리 서비스에서 발생(Publish)하는 이벤트들에 대해, 폴리시 Owner 서비스들이 관심 있는 이벤트에 반응(Subscribe)하여 자율적으로 서비스를 구동함으로써 Orchestration방식이 가진 서비스간 커플링이 전혀 없으며, 이벤트를 수신하는 신규 서비스의 추가 및 이벤트를 수신하던 기존 서비스의 삭제가 아주 자유롭게 수행 가능합니다.

또한, 주문관리 서비스 입장에서도 호출당하는 폴리시를 가진 시스템의 얘기치않은 장애(System Fault)에 대해, 이 방식은 완전히 자유롭다는 것이 가장 큰 장점입니다.

![수행 방법](./../../images/msasc/image12.179003c.a0f816833ae9b56914b432211aa1b165.png)

## 서비스 서열과 역학관계
마이크로 서비스들 간에는 서열이 존재합니다. 이 서열로 인하여 서비스간의 통신 방법이나 리소스 할당 정책등을 정할 수 있습니다.

1. 무엇을 우선적으로 챙길 것인가?
2. 어느 마이크로 서비스의 인터페이스를 더 중요하게 관리할 것인가?
3. 마이크로서비스간 트랜잭션의 묶음을 어떻게 할 것인가?
4. 무엇을 우선적으로 줄일 것인가?

### 무엇을 우선적으로 챙길 것인가?
회사가 점점 커지면서 제공하는 서비스는 조금씩 많아 지게 되는데, 이럴때 마이크로 서비스의 서열을 체크하여 집중해야할 서비스를 결정 할 수 있습니다.

회사에서 버릴수 없는 핵심 기능을 Core Domain 이라고 할 수 있습니다. 아마도 가장 처음에 회사를 생성하게된 핵심 비지니스 라고 할 수 있습니다. 쇼핑몰 시스템에서 주문, 카탈로그 서비스등 이 기능을 제공하지 않으면 회사가 망하는 도메인입니다.

기업의 핵심 경쟁력이 아닌, 직접 운영해도 좋지만 상황에 따라 아웃소싱 가능한 영역을 Supportive Domain 이라고 부를 수 있고, 이는 2순위로 회사에서 가져가야 할 영역입니다. 쇼핑몰 시스템에서 재고관리, 배송, 회원관리 서비스 등이 이에 해당 됩니다. 예를 들어 배송서비스는 직접 운영을 한다면 배송상태를 직접 챙길수 있는 이점이 있지만, 경쟁 회사에서 배송을 더 잘한다면 차라리 외주를 주고, 코어 도메인에 더 집중을 하는게 경쟁력이 더욱 올라갈 것입니다.

서열의 마지막 순위로 다른 회사의 경쟁력이 너무 뛰어나서 오히려 만들면 손해가 나는 서비스가 있을 수 있습니다. 혹은 기업 경쟁력과 무관한 서비스가 있는데, 이를 General Domain 이라고 부른다. 이 영역은 가능하면 구현을 하지 말고, SaaS 서비스를 사용하거나 솔루션을 사는 방법이 더 비용을 아끼는 방법이 될 것입니다. 쇼핑몰 시스템에서 결제, 빌링 서비스 등이 이 영역에 해당 할 수 있습니다. 예를들어 결제시스템을 직접 만든다면, 각종 카드사별 연동과, 지불 방법별 연동 등을 구축해야 하지만, 외부 서비스를 사용하면 PG 사 모듈만 심는 것으로 해결이 될 수 있습니다.

### 어느 마이크로 서비스의 인터페이스를 더 중요하게 관리할 것인가?

![수행 방법](./../../images/msasc/image4.df6d994.7b6eb18bbe243b09830511f1353b3ebc.png)

서비스간의 서열에 따라서 인터페이스간의 역학관계가 생성됩니다.

 1. Core Domain 은 각 팀끼리 서비스가 분리 되어 있어도, 비슷한 개발 수준 역량을 가지고 있을 확률이 높습니다. 또한 핵심 기능을 분리한 경우일수도 있습니다. 코어 도메인간의 관계는 Shared-Kernel 도 허용이 가능합니다. 쇼핑몰 시스템에서 주문과 상품 서비스가 예시가 될수있습니다. 두팀은 그정도 기술적 합의와 수준이 올라가 있는 상황이지만 KPI 는 달라서 서비스를 나눈 상황으로 볼 수 있습니다. 주문을 하기 위해서는 상품 정보가 필수로 필요하니 상품 도메인 클레스를 같이 공유하여 쓸 수 있습니다.

> Shared-Kernel :
> 두개의 MS 가 호출을 주고 받을때 필요한 도메인 클레스들을 라이브러리 형태로 공유하는것입니다. 코드를 공유하고, 심지어 코드를 커밋할수있는 권한까지 공유 하기도 합니다. 상당히 강한 파워를 가진 MS 끼리 허용될수 있습니다.
> Shared-Kernel 을 Shared-Database 라고 생각하면 안됩니다.

 2. Core Domain 과 Supportive Domain 간의 ‘interfacing’ 은 Conformist 관계가 될 수 있습니다. 서비스들 끼리 인터페이스를 맞추려면 코드의 수정이 필요 할 수있는데, 높은 서열의 서비스가 중요도가 낮은 서비스를 위하여 자신의 코드를 수정해 가면서 인터페이스를 맞추는 경우는 없을 것입니다.

> Conformist :
> 힘이 없기 때문에 업스트림에서 주는대로 쓰는 것입니다. 업스트림의 api 가 바뀌면 다운스트림에서 알아서 바꿔야 하는 관계입니다. 예를들어 facebook 의 api 를 사용하여 어플리케이션을 개발 한다고 치면, 특정 api 가 필요하다고 facebook 에 요청을 해도 들어주지가 않을 것입니다.

 3. Core Domain 과 General Domain(외부서비스) 간의 관계는 Anti-corruption Layer 가 필요 할 수도 있습니다. 예를 들어 내부 시스템에서는 메세지 방식을 사용하는데 외부 시스템의 api 를 사용하기 위해서는 두 서비스의 통신방식을 해석하고 변환을 해주는 또 다른 서비스가 필요 할 것입니다.

> Anti-corruption Layer :
> 두 시스템 간의 통신을 변환하여, 다른 응용 프로그램이 해당 디자인 및 기술 방식을 손상시키지 않도록 하여 해당 시스템을 변경되지 않은 상태로 유지하는 방식입니다.

### 마이크로서비스간 트랜잭션의 묶음을 어떻게 할 것인가?

![수행 방법](./../../images/msasc/image5.cbab2cf.6cc3d235ec02e5f6e2f110bc0f6b0739.png)

서비스간의 서열에 따라서 서로간의 트랜잭션 방식을 다르게 선택 할 수 있습니다.

Core Domain 간에 강결합을 사용하는 경우가 생깁니다. 주문시 재고를 확인해야 하는 경우도 있을 수 있고, 재고가 없을 경우 주문이 안되는 식의 설계가 있을 수도 있습니다.
이럴때는 ACID Transaction 으로 두개의 서비스를 묶어 주고, 중요도에 따라서 2PC 방식으로 서비스와 통신이 되는지 확인이 필요 할 수도 있습니다.

Core Domain 과 서열이 낮은 서비스간의 통신은 강한 트랜잭션을 연결해야할 이유가 없습니다. 강 결합을 한다는 것은 항상 상대방 서비스가 정상작동을 해야 한다는 가정이 있습니다. 상품 추천이 안되거나 배송이 처리되지 않는다고 해서 주문을 못 받으면 안됩니다.
Core Domain 과 Supportive Domain간 의 연결은 서로간의 서비스에 영향이 없도록 비동기 혹은 Event-Driven 방식으로 처리를 하는게 좋다. 혹은 상품 추천같이 자체적으로 UI 가 있는 경우 UI-MashUp 도 좋은 방법입니다.

### 무엇을 우선적으로 줄일 것인가?

![수행 방법](./../../images/msasc/image6.2665e34.6d720de2da9b00269805d2e159125860.png)

쇼핑몰에서는 사용자의 요청이 몰려서 서비스에 과부화가 걸리는 상황이 생길 수 있습니다. 이럴때 서비스를 스케일 아웃을 하여 해결을 하게 되는데, 리소스가 한정되어 있다면 Core Domain 을 확장하기 위하여 Supportive Domain 을 중지시킬 수 있습니다.

쇼핑몰에서 배송 서비스는 주문이 폭주하는 시간에 배송 처리를 안하고, 야간에 서비스를 시작하여 처리를 해도 됩니다. 상품 추천 서비스도 주문이 폭주하여 장애가 일어나기 직전인 상황에서는 주문서비스를 살리기 위하여 리소스를 넘겨주는 선택을 할 수도 있습니다.

핵심 서비스인 주문 서비스가 죽었다면 배송처리와 상품추천은 의미가 없어진다. 또한 주문서비스와 배송서비스가 강결합으로 묶여있다면 서비스를 줄이는 선택은 할 수 없을 것입니다. 이렇듯 각각의 마이크로 서비스 간에는 중요도에 따라 우선순위와 역학관계가 존재합니다.

## 아키텍처 설계
### Inner 아키텍처
아래와 같은 육각형 모형의 아키텍처를 헥사고날 아키텍처라고 합니다.
이는 가운데 영역인 비지니스 로직 (도메인 영역)을 손상시키지 않고 프로그램을 구성하도록 고안된 아키텍처입니다.

예를 들어, 우리의 서비스에 외부로 부터 입력되는 데이터는 다양한 형식을 가지고 있을 수 있습니다. 데이터가 xml 이나 json 형식으로 올 수도 있고, 요청되는 프로토콜도 Rest, RPC 방식등을 가지고 있을 수 있습니다.

결국 이렇게 들어온 각종 데이터를 객체로 변환을 시켜야 하는 작업이 필요한데, 이러한 로직들을 도메인 영역에서. 처리를 한다면 (예를들어 객체 안쪽에서 변환작업 처리 등) 도메인 영역은 비대하여지고, 가독성이 떨어질 것 입니다. DDD 에서 말하는 잘 짜여진 코드는 ‘도메인을 보았을때 비지니스 흐름이 보여져야 한다.’ 라고 말합니다. 가독성이 떨어지고 코드가 복잡해지면 결국 잘 짜여진 코드가 될수 없다는 말입니다.

그리하여 나온 방법이 어뎁터를 사용하여 외부에서 들어오는 입력(input)과, 외부로 호출하려는 출력(output)을 처리하는 방식입니다. 어뎁터를 여러개 만들수 있는 구조를 가져서 상황에 맞는 어뎁터를 붙였다가 떼었다가 할수 있도록 구성합니다. 이러한 방법이 헥사고날 아키텍처의 핵심입니다.

그림을 좀더 살펴 보면, 가운데 노란색은 비지니스 영역입니다. 그리고 파란색 도형은 외부로부터의 입력을 컨트롤러 클레스를 이용하여 분리 하였습니다. 컨트롤러에서 변환작업이 있을 것입니다.

하단에 데이터 베이스와의 연결도 어뎁터 패턴으로 분리를 합니다.예를 들어 데이터베이스에 종속적인 Query 를 직접 사용하였다면, 데이터베이스가 변경되는 상황이 발생할때 해당 로직은 모두 다시 만들어야 합니다.

마찬가지로 메세지브로커를 사용하는 경우 특정 브로커(예: 카프카, RabbitMQ 등 )의 호출 코드를 직접적으로 사용하지 않고, 어뎁터 형식으로 사용하는 방법이 좋습니다.

이처럼 비지니스 로직은 순수한 형태로 구현을 하고, 그 이외의 것을 adapter 형식으로 설계를 하여 해당 비지니스 로직이 어느 환경에서도 잘 동작하도록 설계한 모형이 헥사고날 아키텍처이고, 마이크로 서비스 아키텍처에서는 이와 같은 방식을 지향합니다.

![Inner 아키텍처](./../../images/msasc/image1.b306fc5.1da719ff54ffae34e5cbc0d7f17d6974.png)

### MSA Chassis
MSA Chassis 라는 말은 마이크로 서비스를 구축할때 필요한 프레임워크들의 모음입니다. 위에 설명한 헥사고날 아키텍처로 설계하여 비지니스 로직에 영향이 없는 개발을 맨땅에서 하려면 많은 공수가 필요합니다. 이에 많은 프레임워크들이 이와 같은 패턴들을 구성해 놓고 제공중입니다.

Java 계열에서 가장 선두주자인 Spring 프레임워크에서 마이크로 서비스에 적합한 spring-boot 프레임워크를 내어 놓았고, 이에 여러가지 어뎁터들에 해당하는 프로젝트들이 존재합니다. 아래 그림은 헥사고날 아키텍처에 spring-boot를 기반으로 한 MSA Chassis 를 입힌 모형입니다. Spring-Data-Rest 를 사용하여 Data 를 외부와 Rest 방식으로 연결시키고 , String-Cloud-Stream 으로 메세지 처리를 하는 로직을 구현하여 특정 브로커에 종속적이지 않은 adapter 패턴으로 구현된 모형입니다.

![MSA Chassis](./../../images/msasc/image2.63ff18d.7a9da362f221e3a5cb1c658d48f813ff.png)

### Outer 아키텍처
마이크로서비스 아키텍처는 Inner와 Outer 로 구분하고 있으며, Outer 아키텍처는 가트너에서 6개의 서브 영역(아래 참조)으로 세분화하고 있습니다.

![Outer 아키텍처](./../../images/msasc/image3.e8fe0bf.10cb39929b9a4f32705376f3ff5d73b5.png)

#### API Gateway
API Gateway는 마이크로서비스 외부로부터의 통합 접근을 위한 단일창구를 제공하며, 인증, 권한에 대한 통합 제어를 수행합니다.

#### Service Mesh
마이크로서비스의 네트워크 제어뿐만 아니라, 서비스간 Advanced한 호출 제어 및 트랜잭션을 관리 합니다.

#### Container Management
마이크로서비스를 물리적으로 적재하는 기반이며 논리적인 서비스 운영이 가능합니다. 컨테이너 기반의 대규모 마이크로서비스가 관리됩니다.

#### Backing Services
마이크로서비스에서 어플리케이션이 실행되는 가운데 네트워크를 통해서 사용할 수 있는 모든 서비스를 지칭합니다. 예를 들어 데이터베이스, 메시지/큐 시스템,  SMTP 서비스, 캐시 시스템이 있습니다.

#### Telemetry
마이크로서비스 아키텍처의 메트릭 기반 전 구간을 모니터링하며, 물리적으로 분산되어 운영되는 컨테이너 기반의 마이크로서비스에 대한 로그를 수집하고 서비스를 추적합니다.

#### CI/CD Automation
마이크로서비스의 소스Build에서부터 단위테스트와 컨트랙 테스트를 수행하는 Continuous Integration 영역과 도커 이미지를 생성해 운영 환경에 자동 배포되는 Continuous Deployment를 담당합니다.

## 서비스 디스커버리 패턴
분산 환경 위에서 서로간의 서비스를 원격 호출하기 위해서는 각 서비스의 IP 주소와 PORT 를 알아야 호출이 가능합니다. 요즘처럼 클라우드 기반의 MSA 어플리케이션인 경우에 네트워크 주소가 동적(dynamic)으로 할당됩니다. 따라서 클라이언트가 서비스를 호출하기위해서 서비스를 찾는 매커니즘(service discovery mechanism)이 필요합니다.

- Service registry 는 Service discovery 를 하기 위하여 중요한 역할을 합니다.
- Service registry 는 사용가능한 서비스 인스턴스의 목록을 관리하고, 서비스 등록/해제/조회 등을 할 수 있는 API를 제공합니다.
- Service discovery 를 하는 위치에 따라서 구현 방식이 달라지기에 Client-Side 와 Server-Side 로 분리합니다.

Service discovery 기능은 기본적으로 서비스를 등록하고 등록된 서비스의 목록을 리턴하는 기능이지만 Health check 를 통해서 현재 서비스가 가능한 서비스를 판별한 후, 서비스가 가능한 서비스 목록만 보여 준다던가, 서비스간의 부하 분산 비율을 조정하는 등의 확장이 가능합니다.

### Client-Side discovery , loadbalancing

![이미지](./../../images/msasc/image1.4066b56.17d4bb3eb42a30bde52caa127c713cc3.png)

 - 서비스 인스턴스의 네트워크 위치를 찾고 로드밸런싱하는 역할을 클라이언트가 담당하는 방식
 - Netflix Eureka : Service registry
 - Netflix Ribbon : Eureka 와 함께 동작하여 로드밸런싱된 요청(requests)을 생성

Client-Side discovery 방식은 client 가 Service registry 에 물어서 서비스 위치를 찾은 후에 로드밸런싱 알고리즘을 통해 호출을 하는 방식입니다. 서비스가 구동될적에 Service registry 에 자신의 위치 ( ip,prot, 서비스명 등 ) 를 알리고, 종료시에 Service registry 에서 삭제를 합니다.

위 그림은 order-service 가 기동할때 각자 구현된 discovery library 에서 Service registry 가 제공하는 Registration API 를 호출하여 서비스를 등록합니다. 이제 다른 서비스에서 order-service 를 호출하가 위해서는 Service registry 에 Query API 를 호출하여 타겟의 ip 와 port 등을 알아 낸 후 서비스를 호출합니다. 호출시에는 discovery library 에서 로드밸런싱 방법을 선택하여 호출을 합니다.

대표적인 discovery library 는 Netflix 오픈소스인 Eureka,Ribbon 등이 있습니다. Eureka 는 Service registry 의 서버 역할을 하며 API 를 제공하여 주고, 클라이언트 라이브러리로 활용을 할적엔 API 를 호출하는 역할을 합니다. Ribbon 은 Eureka 와 같이 쓰이면서 호출시 로드벨런싱 역할을 해준다.

#### Client-Side Discovery Pattern 장점
- 비교적 간단합니다.
- 호출하려는 서비스를 알고 있기 때문에 서비스에 맞는 로드밸런싱 방식을 각자 구현할 수 있습니다.

#### Client-Side Discovery Pattern 단점
- 각 서비스마다 서비스 레지스트리를 구현해야 하는 종속성이 생긴다.
- 만약 서비스마다 다른 언어를 사용하고 있다면 언어별 또는 프레임워크별로 구현해야 합니다.

### Server-Side discovery , loadbalancing

![이미지](./../../images/msasc/image2.2665e34.2f5816704e08a5508ed8c6c6b011066b.png)

- 서버 쪽에서 디스커버리 로직을 구현한 방식
- aws ELB, 구글 로드 밸런서 : Service discovery
- kube-dns + etcd : Service registry
- kubernetes proxy : Service loadbalancer

Server-Side discovery 방식은 client 가 플렛폼 라우터로 서비스를 호출하여 달라고 요청을 보내는 방식입니다. 여기서 플렛폼 라우터는 aws ELB, 구글 로드 밸런서가 대표적입니다. 이 플렛폼 라우터는 서비스 레지스트리에 문의(query)를 하여 서비스의 위치를 찾은 후에 이를 기반으로 라우팅을 합니다. Client-Side discovery 와 동일하게 각 서비스는 Service registry 에 등록되고 해제 됩니다.

위 그림의 Deployment platform 은 Kubernetes 배포 환경으로 생각 하면됩니다. 만약 Kubernetes 와 aws ELB 를 사용한다면 클라이언트는 DNS 이름을 사용하여 ELB 에 요청을 보냅니다. ELB 에서는 Kube-DNS 서비스에게 DNS 이름으로 문의(query)를 요청하면 Kube-DNS 는 쿠버네티스의 저장소인 etcd 를 조회하여 호출하려는 서비스의 ip와 port 정보를 넘겨준다. 즉 Service registry 역할을 Kube-DNS (API 제공) 와 etcd (목록 관리) 가 나누어서 합니다. 넘겨받은 정보를 ELB 에서 호출을 할때 Kube-proxy 가 loadbalancer 역할을 하여 준다.

####  Server-Side Discovery Pattern 장점
- 디스커버리 로직을 클라이언트에서 분리할 수 있습니다.
- 따라서 클라이언트 쪽에선 이런 로직을 몰라도 되고 따로 구현할 필요도 없습니다.
- 쿠버네티스 서비스 제공자(EKS, AKS, GKS 등) 에서는 이와 같은 기능을 무료로 재공 하고 있습니다.

#### Server-Side Discovery Pattern 단점
- 로드벨런서는 배포 환경에 구축이 되어야 합니다.
- public cloud 에서 (예: aws, gcp) 로드 벨런서를 생성하면 각 환경에 맞는 로드벨런서 (aws ELB, 구글 로드 밸런서) 등이 자동 생성되지만, - private cloud 에서는 로드벨런서를 직접 생성해 주어야 합니다. (예: MetalLB 등)

서비스 디스커버리가 죽으면 전체 시스템이 동작하지 않기 때문에 고가용성 등 더 많은 관리가 필요합니다.

###  registration 방식
서비스들은 Service Registry 에 각 서비스를 등록/해제 해야합니다. 이렇게 서비스를 등록하는 방식은 두가지 방식이 있습니다.

#### 1. Self-Registration
서비스 인스턴스는 service registry에 스스로 등록/해제할 책임이 있습니다.
필요하다면 등록정보가 만료되지 않게 하기위해 heartbeat를 service registry에 보내야합니다.
Netflix OSS Eureka client 가 대표적인 예 입니다.

Eureka client는 Eureka(service registry)에 서비스 등록/해제를 자동으로 처리합니다.
서비스의 Java Configuration 클래스에 @EnableEurekaClient 어노테이션만 달아주면 됩니다.

##### Self-Registration 장점
- 비교적 단순합니다.
- 별도의 시스템 컴포넌트가 추가될 필요가 없습니다.

##### Self-Registration 단점
- 서비스 인스턴스와 Service Registry간의 높은 결합도(coupling)이 생긴다.
- 서비스에서 등록/해제 관련된 코드를 구현해야됩니다.

#### 2. 3rd party registration
서비스 인스턴스가 직접 service registry에 등록/해제에 대한 책임이 없습니다.
대신, 서비스 등록기(service registrar)가 service registry에 등록을 해준다.
서비스 등록기는 실행중인 서비스 인스턴스들에 polling을 하거나 이벤트를 구독하는 등의 작업을 통해서 서비스의 변경을 감지하고, service registry에 등록/해제를 합니다.
Netflix Prana 나 Registrator 등이 이에 해당합니다.
쿠버네티스에서는 명식적인 Service registry 가 없어서 infrastructure 의 built-in registry 를 이용합니다.

> Netflix Prana : Non-JVM 시스템을 side-car 방식으로 같이 실행을 하여 Eureka 에 등록/해제 를 하여준다.
> Registrator: Docker containers 를 다양한 (etcd, Consul) Service registry 에 등록/해제 하여 준다.

##### Third-Party Registration 장점
- 서비스 인스턴스와 service registry가의 결합도를 끊을(decoupled) 수 있습니다.
- 서비스에 별도의 등록/해제 로직을 구현할 필요가 없습니다.

##### Third-Party Registration 단점
- 운영환경에 추가적인 시스템 컴포넌트가 필요합니다.
- 이 시스템은 설치 및 관리되어야 하고, 고가용성을 유지해야 합니다.

> 참고 :
> https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/
> https://kihoonkim.github.io/2017/01/27/Microservices Architecture/Chris Richardson-NGINX Blog Summary/4. Service Discovery in a MSA/
> https://microservices.io/patterns/3rd-party-registration.html


## 마이크로서비스 보안설계
모노리스 시스템에서 인증, 권한 부여 및 기타 다양한 중요 보안 조치를 다루는 중앙 집중식 보안 모듈을 사용하는 경우가 많았다. 그러나 마이크로 서비스에서 중앙 집중화는 분산 배포의 이점을 떨어뜨리고, 효율성을 감소시킨다.
결국 중앙 집중식 세션 관리보다 확장 가능한 방법이 요구 되어지는데, 모든 마이크로 서비스에서 보안 모듈을 심기 보다는 단일 진입점을 제공하는 API 게이트웨이에서 처리하는 것이 효율적입니다. 이 API 게이트웨이에서 사용자 체크와 서비스에 접근 할 수 있는 권한 부여 및 인증을 처리하게 됩니다.

### 인증/인가
#### 인증(Authentication) 과 인가(Authorization)란?
##### 인증(Authentication)
- 사용자인지 아닌지를 확인. 주로 아이디/패스워드 인증이 많이 사용되나 생체인식 등의 인증도 사용.
- 서비스를 호출하는 서비스 클라이언트가 자신이라는 것을 어떻게 알 수 있을까?
- who you are
- 사원증 발급

##### 인가(Authorization)
- 사용자가 권한이 있는지 없는지 확인하여 해당 행위를 제한하거나 가능하게 하게 함.
- 마이크로서비스를 호출하는 서비스 클라이언트가 수행하려는 작업을 수행할 자격이 있는지 어떻게 알 수 있을까?
- what you can do
- 사원증 찍고 게이트 통과

#### Rest API 인증 방법
##### 1. HTTP Basic Authentication
- 사용자 이름과 암호 Base 64 인코딩을 하여 서버로 전송.
- 요청 할 때 마다 사용자 이름과 암호를 전송해야 합니다.
- 중간자 공격(Man-in-the-middle attack)에 취약합니다.

##### 2. Cookies and Session
- 세션은 키를 사용자 아이디에 매핑합니다.
- 세션이 존재하는 경우 키가 유효한 것으로 판단합니다.
- 매 요청마다 쿠키에서 키를 보내 인증을 하여 세션이 유효한지 판단합니다.
- REST API 의 기본 원칙인 Stateless에 위배 됩니다.

##### 3. API Keys
- 로그인 후 API키를 받아서 전달받아서 매 요청시마다 API키를 전달하는 방법.
- API키가 유출될시 보안문제가 생길 수 있습니다.
- 주기적으로 키를 업데이트 하더라도, 서버와 클라이언트가 잘 맞지 않으면 서비스 장애로 이어진다.
- Cloud 의 상징인 Auto Scaling 등으로 서버의 수가 변하고 IP가 유동적이라면 사실 상 관리가 되지 않는다.

##### 4. OAuth 2.0 (Open Authorization) (Token in HTTP Header)
API Key의 단점을 보완하여 요청하는 서버와 요청받는 서버 정도로 단순한 구성이 아닌, 요청하는 서버, 요청받는 서버, 그리고 인증하는 서버 등으로 조금 세분화가 이루어진다. (중립적인 위치에서 인증을 전담하는 구조)
OAuth 1.0 보다 인증 절차를 간소화 하고 다양한 인증 방식을 지원 합니다.
OAuth 1.0 은 디지털 서명 기반이었지만 OAuth2.0의 암호화는 https에 맡김으로써 복잡한 디지털 서명에관한 로직을 요구하지 않기때문에 구현 자체가 개발자입장에서 쉬워진다.

#### Oauth 2.0
Oauth 2.0 를 조금더 간단히 요약하면 웹, 모바일 어플리케이션에서 타사의 API를 사용하고 싶을 때 권한 획득을 위한 프로토콜(Protocol) 입니다.
어떤 site 를 들어갔을때 “facebook으로 로그인”, “Google 계정으로 로그인” 등을 볼 수 있는데, 이것은 OAuth2.0 를 이용하여 특정 서비스에 대한 회원가입 과정을 거치지 않고 기존에 사용하던 서비스들의 계정으로 로그인을 진행하는 방법입니다. 구글이나 페이스북의 로그인 화면이 나온 후 계정 클릭시, 각종 권한 획득에 관한 수락을 요청하는 방식으로 로그인이 처리됩니다. 이러한 과정들이 사용되는 방법을 알아 본다.

사용 용어 :
- Client : 사용자가 사용하려는 서비스. (예: 웹 홈페이지)
- Resource Owner : 사용자
- Authorization Server : 사용자의 동의를 받아서 권한을 부여하는 서버 (보통 Resource Server 의 하위 도메인)
- Resource Server : 서비스에 자신의 API를 제공하는 타사 서비스. (예: 구글,페이스북 등)

아래 그림은 Oauth2.0 의 일반적인 권한 허용 흐름입니다.

![이미지](./../../images/msasc/image1.d95422c.be46ccb13513f3755aa15bc784eb8fab.png)

1. 클라이언트가 자원 소유자에게 권한 요청
2. 자원 소유자가 권한을 허가시, 클라이언트는 권한 증서를 발급받음
3. 클라이언트는 권한증서를 가지고 토큰을 권한 서버에 요청
4. 권한증서의 유효성을 체크하고 토큰을 발급해줌
5. 클라이언트는 토큰을 사용하여 자원 요청
6. 토큰 유효성 확인후 요청 처리

#### 권한요청 방법(Grant)
권한을 요청하는 방법(Grant)은 총 6가지의 방법이 있습니다. 해당 방법에 대하여 장단점을 설명합니다.
##### 1. Authorization Code Grant

![이미지](./../../images/msasc/image2.7201738.e0f490b700371d6a193e65ff3385f106.png)

- 구글,페이스북,카카오등 유저 정보가 다른 시스템에 있을때 사용하는 방식
- 어플리케이션이 인증서버에 요청해 브라우저를 열어서 사용자가 인증을 진행하게 하는 방식으로 사용
- 토큰요청시 코드를 요청하는 단계가 있어서 보안에 효과적
- 가장 복잡하지만, 가장 많이 쓰임 > 개발자만 고생하면됨

##### 2. Implicit Grant

![이미지](./../../images/msasc/image3.e8cdb81.b6fba698de9934b69948633cdb5fd698.png)

- Authorization_code 방식에서 코드를 요청하는 프로세스를 제거하고, 바로 토큰을 return
- Javascript 로 동작하는 SPA(Single Page Application)에서 사용하기 위해 만들어 졌으나 권장하지 않음
- 신뢰성 있는 앱 또는 단말기에서 사용
- 외부에 있는 Oauth 서버가 cors 를 지원하지 않을때 사용

##### 3. Resource Owner (Password) Credentials Grant

![이미지](./../../images/msasc/image4.60e6b07.ef116627ff86082cf66d7eb337d6ef29.png)

- 타사의 인증 서버를 사용하지 않고, 자신의 서비스에 인증시 사용 ( 자신이 유저정보를 가지고있고, 내 서비스만 인증할때 )
- Oauth 2.0 의 가장 간단한 인증중 하나
- 전통적으로 이름과 비밀번호로 인증

##### 4. Client Credentials Grant

![이미지](./../../images/msasc/image5.3dbe52b.c64441a0345a21fc918204f7de29b510.png)

- 사용자가 아닌 응용프로그램 (client) 이 인증을 요청할때 사용 ( Resource Owner = Client )
- 접근 권한이 한정되어있는 프로그램 사용시 활용
- 신뢰성이 높은 관리자용 Desktop App 이나 Mobile App 에서 사용

##### 5. Device Code Grant
장치 코드 부여 유형은 브라우저가 없거나 입력이 제한된 장치에서 사용.

##### 6. Refresh Token Grant
기존에 저장해둔 리프러시 토큰이 존재할 때 엑세스토큰을 재발급 받을 필요가 있을 때 사용합니다. 그리고 기존 액세스는 토큰이 만료됩니다.

### 마이크로 서비스 보안을 쇼핑몰에 적용 예제
Oauth2.0 과 JWT 토큰을 사용하여 쇼핑몰에 적용한 예제를 살펴본다.

- 우선 Client 는 사용하고자 하는 서비스 이기 때문에 쇼핑몰 ui 가 될 수 있습니다.
- 쇼핑몰에 접속시 사용자는 자기자신을 확인 하는 로그인을 하게 되는데, 로그인 정보를 확인 하는 Grant 는 1. Authorization Code Grant, 2. Implicit Grant, 3. Password Credentials Grant 방식을 사용 할 수 있습니다. Authorization Server 를 구축하지 않고 타사 인증 서비스를 사용한다면, 1번 방법밖에 사용 할 수 없지만, Authorization Server 를 구축 하였기에 모든 Grant 를 사용 할 수있습니다. 그중 ui 에서 권한을 요청하는 방식은 3. Password Credentials Grant 방식 으로 예제는 구축되어 있습니다.
- Resource Owner는 사용자 정보이고, Authorization Server 에 사용자 정보를 같이 가지고 있는 방식으로 예제를 구축하였습니다. 이렇게 인증서버가 사용자 정보를 같이 포함하고 있는 서버를 IAM(Identity and Access Management) 서버라고 부른다.
- Authorization Server 는 Spring security 를 사용하여 구축 하였고, 토큰 요청시 JWT 로 변환하는 작업을 포함 하였습니다.
Resource Server 는 토큰이 유효한지 체크를 하고, 유효하면 api 를 허용하는 역할을 하기에, Gateway 서비스에 구현을 하였습니다.

> 참고 소스 코드 :
> [Authorization Server,Resource Owner - Oauth]: https://github.com/event-storming/oauth
> [Resource Server - Gateway]: https://github.com/event-storming/gateway
> [Client - UI]: https://github.com/event-storming/ui

#### Authorization Server 사용
1. https://github.com/event-storming/oauth 를 git clone 합니다.
2. cd oauth 접속 후 mvn spring-boot:run 으로 서버를 실행합니다.
3. 로컬에서 실행시 localhost:8090 으로 서버가 실행 됩니다.
  - 서비스(ui)에서 Password Credentials Grant 방식으로 권한증서를 요청하기 위해서는 인증서버에서 발행하여 주는 Client_id, Client_Secret 정보를 모두 알고 있어야 합니다.
  - 서버가 실행시 유저 정보를 임의 값으로 생성 메모리 db 에 넣어주었습니다. (https://github.com/event-storming/oauth/blob/master/src/main/java/com/example/template/AuthorizationServerApplication.java)
  - 서버가 실행시 Client 정보를 임의 값으로 생성 메모리 db 에 넣어주었습니다. (https://github.com/event-storming/oauth/blob/master/src/main/java/com/example/template/config/OAuth2AuthorizationServerConfig.java)

4. 토큰을 요청하는 api 는 /oauth/token 입니다. 요청시 grant_type=password username, password 를 같이 입력 하고, header 에 Client_id, Client_Secret 정보를 base64 로 인코딩 하여 요청합니다.
  - http --form POST localhost:8090/oauth/token ‘Authorization: Basic dWVuZ2luZS1jbGllbnQ6dWVuZ2luZS1zZWNyZXQ=’ grant_type=password username=1@uengine.org password=1
  - Basic 인증은 가장 일반적인 인증 스키마 입니다. base64를 이용하여 인코딩된 사용자 ID/비밀번호 쌍의 인증 정보를 전달합니다. base64는 복호화가 가능한 인코딩이기에 안전하지 않고 HTTPS / TLS 와 같이 사용을 하여야 보안상 안전해 진다. (예제에서는 https 를 사용하지는 않았다.)
  - 토큰 요청시 JWT 토큰과 추가로 서버에서 설정한 additionalInfo 값이 return 됩니다. 해당 토큰을 사용하여 자원요청을 하면 됩니다.

#### client 에서 Authorization Server 호출과 토큰 저장
1. client (ui) 에서 인증서버로 http 요청을 하는 코드는 다음과 같다. 클라이언트는 알고있는 Client_id, Client_Secret 정보를javascript 에서 base64 로 변환하는 방법인 btoa() 를 사용하여 인코딩 후 basic 스키마로 토큰 요청을 합니다. (https://github.com/event-storming/ui/blob/master/src/store.js)

2. 정상적으로 토큰 발행시 토큰 정보는 브라우저의 storage 인 localstorage 에 저장을 합니다. localStorage.setItem('accessToken', accessToken)
  - 브라우저에서는 토큰을 api 요청시마다 사용을 하기 때문에 저장을 해야 합니다. 브라우저에서 토큰을 저장하는 방식은 크게 웹 스토리지에 저장을 하거나, cookie 에 저장을 하는 방식이 있습니다.
  - 브라우저 웹 스토리지는 로컬스토리지와 세션스토리지 두가지 방식이 있습니다. 로컬스토리지는 삭제를 하지 않는 이상 브라우저를 종료하여도 정보가 남아있고, 세션스토리지는 브라우저를 종료하면 정보가 사라지는 방식입니다. 토큰은 자체 유효시간이 존재하기에 로컬스토리지에 저장을 하는것이 조금더 나은 방식입니다.
  - 쿠키는 자체적으로 이름, 값, 만료시간등을 가지고 자바스크립트나 서버에서도 사용할수 있는 값이지만, 4KB 만 저장을 할수 있는 용량문제로 토큰을 저장하는 방식에는 맞지 않다.

3. client (ui) 에서 각종 api 를 요청시 header 값에 토큰을 실어서 같이 보냅니다.
  - http localhost:8088 'Authorization: Bearer $TOKEN’
    curl localhost:8088/orders --header ‘Authorization: Bearer $TOKEN’
  - Bearer 스키마는 Oauth 2.0 의 보안 리소스를 요청하는 방식입니다. (https://tools.ietf.org/html/rfc6750)

#### Resource Server 에서 토큰 유효성 확인
1. Gateway 는 spring-cloud-gateway 를 사용하였습니다. spring-cloud-gateway 는 web reactive 방식을 사용하기 위하여 spring5 의 webflux 방식으로 구현이 되어있습니다. 그러기에 security 적용을 위하여 spring-security-webflux (https://docs.spring.io/spring-security/site/docs/current/reference/html/webflux-oauth2.html) 방식을 사용하여 리소스 서버를 구축해야 합니다.
  - webflux 방식에서 jwt 토큰을 인증 하는 방식은 jwk-Set-Uri 를 구성하여 jwt 토큰 생성시 사용한 Key 값을 체크합니다.

```java
@GetMapping('/.well-known/jwks.json')
@ResponseBody
public Map<String, Object> getKey(Principal principal) {
    RSAPublicKey publicKey = (RSAPublicKey) this.keyPair.getPublic();
    RSAKey key = new RSAKey.Builder(publicKey).build();
    return new JWKSet(key).toJSONObject();
}
```

  - @EnableWebFluxSecurity 를 선언하여 들어오는 모든 요청을 검사 하고, 그중에서 ServerHttpSecurity http.oauth2ResourceServer().jwt() 역할을 선언하여 토큰 검증을 실시 합니다.
(https://github.com/event-storming/gateway/blob/master/src/main/java/com/example/template/ResourceServerConfiguration.java)

## 프론트-엔드 설계
### 웹 개발 패러다임의 변화
초창기 웹 페이지는 (~2000) html 을 사용한 정적인 text 와 image 로 이루어진 화면이 대다수 였습니다. 점차적으로 고속 인터넷과 사용자의 눈높이가 높아지면서 사용자와 반응을 할 수 있는 동적인 웹이 등장을 하며 웹개발이 활성화 되었습니다.

2001년 부터 웹 언어가 활성화 되어 동적인 페이지를 생성하기 위하여 ASP, JSP, PHP 등의 서버 렌더링 기법이 나오기 시작하였습니다. 그리고 내용을 보관하기 위한 데이터베이스가 중요해져서 활용되기 시작하였습니다. 이때부터 view 와 model 을 구분하려는 노력이 나오게 되었고, MVC 패턴이 유행을 하게 되었습니다. 그러나 Html 위에 PHP 등의 코드를 올려서 개발하였던 방법은 복잡성이 높아서 유지보수에 큰 어려움을 겪었고, JPS 같은 서버에서 데이터를 처리하는 방법도, 사용자가 많아지면 서버에 과부하가 걸리기 시작하였습니다.

2005년에 구글에서 구글맵을 공개 후 AJAX(Asynchronous Javascript And XML) 를 이용하였다고 밝히면서 비동기 HTTP Request 기술이 발전하였고, 데이터 전송방식을 XML 이 아닌 JSON 으로 주고 받는 방식으로 변화 하였습니다. 이때부터 웹 서비스로 불리는 API 들이 생기게 되면서, 자연스레 웹에서 비동기로 API 를 호출하고, JSON으로 통신을 하는 개발 방식이 보편화 되었습니다.

2013년대 부터 reactive (반응형) 패러다임이 유행하면서 SPA(Single Page Application) 방식으로 웹 개발이 이루어 지게 되었습니다. 이는 브라우저에서 전체 페이지를 서버에 요청을 하는 것이 아니라, 최초 한번 전체 페이지를 로딩 한 후에 이후부터는 데이터만 변경을 하여 사용하는 방식입니다. 데이터를 처리하는 위치가 서버가 아닌 클라이언트이기 때문에 클라이언트 사이드 랜더이라고 부른다.

> 참고:
> https://unikys.tistory.com/310
> https://ideveloper2.tistory.com/76

### MVVM (Model + View + View Model) 패턴
마이크로 서비스 아키텍처가 유행을 타면서 더이상 MVC 패턴으로 개발이 힘들어 지게 되었습니다. MVC 패턴은 Model 과 View 사이에 Controller 를 두어서 사용자의 입력을 처리하도록 고안이 되었습니다. 즉 View 에서 사용자의 요청을 Controller 가 받아서 Model 을 변화 시킨 후, return 할 View 를 선택하여 Model 을 보내는 방식으로 단순하지만 View 와 Model 의 의존도가 너무 강하여 다양한 서비스가 존재하는 MSA 에는 적합하지 않다.
이에 Model 이 View 를 몰라도 처리를 할수 있는 방식인 MVVM 주목 받게 되었습니다.

MVVM 패턴은 2005년에 Windows의 그래픽 프레임워크인 WPF(Windows Presentation Foundation)와 Silverlight에서 처음 적용되었고, 주요 목적은 To simplify event-driven programming user interfaces 입니다. 이것을 위해 View에 관한 로직과 비즈니스 로직을 철저히 구분합니다. 여기서 사용되는 주요한 개념이 Data binding 입니다.

![이미지](./../../images/msasc/image1.3c07012.b7915537253c1ab22ba276f1eefe6f55.png)

단어의 개념을 살펴보면 다음과 같다.

- Model : 어플리케이션에서 사용되는 데이터와 그 데이터를 처리하는 부분입니다.
- View : 사용자에서 보여지는 UI 부분입니다.
- View-Model : View 와 Model 사이에서 인터페이스 역할. View 와는 Binding 이나 Command 로 연결하고 Model 과는 데이터를 주고 받는 역할을 담당합니다.

View에서 사용자의 요청이 들어오면 Command 패턴을 통해 View-Model에 명령을 내리게 되고 Data Binding으로 인해 View-Model의 값이 변화하면 바로 View의 정보가 바뀌어져 버리게 되는 방식입니다.

- MVVM 의 장점은 View 와 Model 사이의 의존성이 없어서 각 구성요소를 독립적으로 작성하고 테스트가 가능하며, 모듈화 하여 개발이 가능합니다.
- MVVM 의 단점은 View-Model 의 설계가 어렵다.

> 참고 :
> https://beomy.tistory.com/43

### 사용 프레임워크
마이크로 서비스의 프론트 앤드 기술로 중요한 점은 MVVM 패턴을 사용하고, Web Components 기법으로 마이크로 서비스의 컴포넌트를 생성하여 관리하는 것입니다. Web Components 를 지원하는 라이브러리로 유명한 것은 Bit, Polymer elements, Vaadin components 등이 있고, 이러한 라이브러리를 잘 사용할수 있도록 지원해주는 프레임워크로 가장 많이 쓰이는 것은 Vuejs, Angular, React 가 대표적입니다.

2019년 이전에는 구글에서 나온 Angular와 페이스북이 개발한 React 가 인기가 있었지만, 2019년 이후로는 Vuejs 가 폭발적으로 인기를 끌면서 최근에는 3개의 프레임워크를 비교한 글들이 많이 나오고 있습니다. 3개의 프레임워크가 각각의 장단점이 있어서 잘 비교를 해보고 사용을 하면 됩니다. 다만 W3C Web Components 의 표준으로 지정된 프레임워크는 Polymer와 Vuejs 입니다.

아래 이미지는 블로그 글중에서 3가지 프레임워크를 잘 정리한 표가 있어서 가져왔다.

![이미지](./../../images/msasc/image2.0458eca.9dbe982931cea7db0ff001e4a369f9c2.png)

> 참고:
> https://blog.bitsrc.io/9-web-component-ui-libraries-you-should-know-in-2019-9d4476c3f103
> https://gradler.tistory.com/14
> https://www.codeinwp.com/blog/angular-vs-vue-vs-react/
